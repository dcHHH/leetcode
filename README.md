# LeetCode
[toc]

## 287
`O(1)`space and `O(n)`time的解：
`nums[a] = b`当做`a.next = b`，则数组长度为n+1且数组的值在1到n时，数组出现重复的数等效于链表出现环（第二次出现重复的数时，链表指针又指向该数的结点）。
选取两个指针，slow步长为1，fast步长为2。假设两个指针第一次相遇在第k步，环的长度为r，则`2k - k = nr,k = nr`。设链表的起始结点到环的起始结点距离为s，链表的起始结点到第一次相遇的结点距离为k。环的起始结点到第一次相遇的结点距离为m。则`s = k - m`。`s = nr - m = (n - 1)r + (r - m)`，`n = 1`时，一个指针从链表的起始结点出发，另一个结点从相遇的结点出发，步长都为1，第一次相遇的结点即为环的起始结点。

## 442
`1 ≤ a[i] ≤ n`（n：数组长度），将`array[a[i]]`的值乘-1，~~数组出现正数，则该正数的索引出现两次~~（有些数组中有些数可能一次也没出现，也为正数）。判断`array[a[i]]`的值，为负，则是第二次检测到该索引，因此该索引出现两次。

## 448
`1 ≤ a[i] ≤ n`（n：数组长度），将`array[a[i]]`的值变为`-abs(array[a[i]])`，最后数组中值为正数的，说明该索引没有出现，即该索引对应的值没有出现。

## 463
相邻两格不同，则含有一条边，周长加一。遍历将行的结果与列的相加。

## 496


## 561
给定数组之和为定值，每个数对之间的相差越小，则每个数对中较小值之和最大。将数组排序之后，求和以2为步长，即为结果。

